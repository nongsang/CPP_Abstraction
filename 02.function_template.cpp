#include <iostream>
using namespace std;

template <typename T>

T Func(T a)
{
	cout << "매개변수 : " << a << endl;
	return a;
}

template <typename T>

T Add(T a, T b)
{
	return a + b;
}

int main()
{
	cout << "int\t" << Func(3) << endl;
	cout << "double\t" << Func(2.5) << endl;
	cout << "char\t" << Func('A') << endl;
	cout << "char*\t" << Func("C++") << endl;

	cout << endl;

	cout << Add(3, 4) << endl;
	cout << Add(2.6, 3.2) << endl;
	cout << Add('a', 'b') << endl;				// 가능하지만 쓰지 말자
	//cout << Add("C++", "Language") << endl;	// 이건 불가능
}

// 4, 6번째 줄
// 템플릿을 사용하여 함수를 구성한다.
// 틀만 맞춰놓고 자료형은 알아서 맞추도록 코딩한 것이다.
// 함수 오버로딩보다 더 생산성이 높고, 모호성이 적으며, 가독성이 뛰어나게 코딩이 가능하다.

// 12, 14번째 줄
// 템플릿을 이용하여 두 수를 받아 더하기 작업을 하는 함수를 구성하였다.
// 한가지 주의할 점은 템플릿을 사용하기 위해서는 템플릿 선언을 한번씩 해주어야 한다는 것이다.
// 템플릿을 한번 선언한 후 함수를 구성했으면 다른 템플릿 함수를 구성하기 위해서는 템플릿을 한번 더 선언해야 한다는 것.
// 12번째 줄 템플릿 선언을 생략하면 Add()함수는 사용이 불가능하다.

// 21 ~ 24번째 줄
// 템플릿을 이용한 Func()함수에 값을 전달한다.
// int, double, char, char* 모두 전달이 가능하다.
// 템플릿을 이 모든 자료형을 알아서 선택하고 작업을 수행한다.

// 28, 29번째 줄
// Add()함수에 값을 전달하여 더하기 연산을 한다.
// Add()함수 또한 템플릿을 사용하였으므로 자료형을 자동으로 선택하고 결과 또한 자동으로 도출해낸다.

// 30번째 줄
// char형 자료를 전달한다.
// 연산은 가능하지만 사용하지 말자.
// 왜냐하면 Add()함수는 '+' 연산을 한다.
// 문자를 전달하면 아스키코드로 자동 변환하여 연산을 한 후 문자로 출력한다.
// 그러므로 엉뚱한 값이 나오는 것

// 31번째 줄
// 문자열을 전달하고 있다.
// 문자열은 char*형이다.
// 포인터끼리 사칙연산은 불가능하므로 사용할 수가 없는 것.