#include <iostream>

using namespace std;

class CTest
{
	int* m_nData{ nullptr };	// 포인터형 멤버변수를 nulltpr로 초기화
public:
	CTest(int nParam)
	{
		cout << "생성자" << endl;
		m_nData = new int;			// 멤버변수 동적할당
		*m_nData = nParam;			// 동적할당된 멤버변수에 값 저장
	}

	~CTest()
	{
		cout << "소멸자" << endl;
		delete m_nData;				// 여기서 문제 발생
	}

	int GetData() const { return *m_nData; }
};

int main()
{
	CTest a(10);	// 인스턴스 생성
	CTest b(a);		// CTest b = a;

	cout << a.GetData() << endl;
	cout << b.GetData() << endl;
}

// 7번째 줄
// 멤버변수가 int*형이며 nullptr로 초기화하였다.
// C++11로 올라와서 NULL대신 nullptr이라는 새로운 값을 이용하여 포인터 변수의 초기화를 할 수 있다.
// NULL값은 0으로 나오므로 버그를 유발하였다.
// nullptr은 아무것도 가리키지 않으므로 이걸 애용하자

// 12번째 줄
// 생성자를 호출하면서 멤버변수를 동적할당하였다.

// 13번째 줄
// 동적할당된 멤버변수에 값 저장하였다.

// 19번째 줄
// 생성자를 호출하면서 동적할당하였으므로 소멸자에서 메모리해제를 해준다.

// 27, 28번째 줄
// 인스턴스를 생성하면서 복사생성을 하였다.

// 여기서 문제가 발생하는 부분은 19, 28번째 줄
// 28번째 줄에서 복사생성자가 호출이 된다.
// 하지만 복사생성자는 정의가 되어있지 않고, 동적할당은 생성자에만 정의되어있으므로 복사할 때 동적할당이 되지 않는다.
// 복사생성이 될 때 원본은 힙에 생성이 되어있고, 복사생성은 스택에 생성이 된다.
// 힙을 원본으로 스택에 생성하려는 접이 중요하다.
//
// 19번째 줄에서 동적할당 하였으므로 메모리해제하고있다.
// 원본은 힙에 생성이 되어있으므로 메모리해제가 가능하다.
// 하지만 복사생성이 된 복사본은 힙에 존재하지 않으므로 메모리해제를 하면 오류가 뿜뿜일 수 밖에 없다.
// 이를 해결하여면 깊은 복사(deep copy)를 하면 된다.