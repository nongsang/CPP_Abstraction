#include <iostream>
using namespace std;

template <typename T>		// 템플릿 선언
class CTest
{
protected:
	static T m_Data;		// 멤버변수는 정적으로 선언
public:
	CTest();
	T TestFunc();
};

template <typename T>		// 또 선언하네?
CTest<T>::CTest() {}		// 생성자는 앞에 T 안써주네

template <typename T>		// 템플릿은 한번 쓸때마다 다시 선언해야 하나?
T CTest<T>::TestFunc() { return m_Data; }		// 멤버함수는 T 써주고

template <typename T>		// 맞네 한번 쓸때마다 다시 선언해야하네
T CTest<T>::m_Data = 15;			// 멤벼변수도 T 써줌. 근데 여기서 중요

int main()
{
	CTest<double> a;		// int형으로 썼었는데 double형으로 해줘도 되나?
	cout << a.TestFunc() << endl;
}

// 8번 줄
// 멤버변수를 정적으로 선언해주었다.
// 이게 어떤 의미인지 나중에 설명

// 4번 줄
// 템플릿 선언을 하였다.
// 템플릿은 클래스 내에서 계속 사용하였다.
// 아마도 템플릿은 한번 선언하면 계속 사용이 가능하겠지?

// 14, 17, 20번 줄
// 또 템플릿을 선언해주었다.
// 이것을 보면 템플릿은 클래스 정의 전에 한번 써주면 클래스 정의 내내 사용 가능하다.
// 클래스 외부에서 클래스를 정의해줄 때마다 템플릿 선언을 해줘야 한다.

// 15번 줄
// 생성자를 외부에서 정의해주었다.
// 여기서 중요한 것은 앞에 T를 사용해주지 않았다는 것.
// 이 말은 반환형이 없는 생성자는 T를 사용해주면 안된다는 뜻이다.

// 18번 줄
// 멤버함수를 외부에서 정의해주었다.
// 생성자, 소멸자를 제외하고 반환값이 있다는 것을 가정하므로 앞에 T를 사용해주어야 한다.

// 21번 줄
// 멤버변수를 외부에서 정의해주었다.
// 멤버함수만 반환값이 있는 것이 아닌 멤버변수도 반환값이 있다고 생각하고 앞에 T를 붙여줘야 한다.
// 여기서 중요한 것은 멤버변수가 static으로 선언이 됬다는 것이다.
// 클래스 내에서는 어차피 값의 변경이 허용이 된다.
// 하지만 밖에서 값을 변경하려면 static으로 선언해야 한다.

// 외부정의는 파일분할에서 자주 쓰이므로 잘 기억해두자