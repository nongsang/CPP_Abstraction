#include <iostream>

using namespace std;

template<typename T>	// A
void TestFunc(T)		// 기본 템플릿 함수, 가장 기본적이다.
{
	cout << "TestFunc(T)" << endl;
}

template<typename T>	// B
void TestFunc(T*)		// 포인터 특수화
{
	cout << "TestFunc(T*)" << endl;
}

//template<>				// C
//void TestFunc<int>(int*)	// B의 특수화 버전
//{
//	cout << "TestFunc<int>(int*)" << endl;
//}

template<>					// D
void TestFunc<int*>(int*)	// C하고 비슷한데, C와 번갈아가면서 호출해보자
{
	cout << "TestFunc<int*>(int*)" << endl;
}

int main()
{
	int *p{ nullptr };		// 포인터 변수
	TestFunc(p);			// 어떤 함수가 불리지?
}

// 5 ~ 9번 줄
// 기본 템플릿 함수이다.
// A로 정의

// 11 ~ 15번 줄
// 포인터에 대한 특수화 함수이다.
// B로 정의

// 17 ~ 21번 줄
// 포인터에 대한 특수화를 명시적으로 작성한 함수이다.
// C로 정의

// 23 ~ 27번 줄
// 포인터에 대한 특수화를 명시적으로 작성한 함수이다.
// C하고 비슷하지만 다르다.
// C는 <int>고, D는 <int*>이다.
// 확실하게 모든 자료형을 다 맞춰줬다.
// 이제부터 C와 비교해서 테스트를 한다.

// 32번 줄
// 포인터 변수를 인자로 함수를 호출한다.
// D는 없고 C만 있다면 당연히 C가 호출이 된다.
// int*형을 인자로 보내줬으므로 특수화를 int로 해줬어도 통하는 것.
//
// 만약 C가 없고 D만 있다면 어떤게 호출될까?
// 특수화도 int*고 인자도 int*로 사용하며 파라미터로 int*를 사용했으니 D가 호출되겠지?
// 하지만 충격적이게도 B가 호출이 된다.

// 여기서 알아낼 수 있는 사실은 '포인터형 특수화는 오버로딩이 되지 않는다.'
// 기본형 템플릿 특수화는 얼마든지 오버로딩이 가능하다.
// 하지만 포인터형의 템플릿 특수화는 불가능하다.

// 템플릿 특수화는 템플릿을 사용한다면 반드시 사용해야 할 것 이다.
// 하지만 남발하면 가독성을 떨어뜨린다.
// 가능하면 일반함수로 정의하여 사용하자.
// 어쩔 수 없이 사용해야 한다면 포인터형은 특수화 하지말자.